#!/usr/bin/env python3
"""
XSLT Transformation System for Multiple Output Formats
Transforms TEI XML to HTML, LaTeX, EPUB, DOCX and other formats
Supports academic publishing and web distribution
"""

import os
import subprocess
from pathlib import Path
from typing import Dict, List, Optional, Union, Any
import logging
from tempfile import TemporaryDirectory
import shutil

# Set up logging
logging.basicConfig(
    level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s"
)
logger = logging.getLogger(__name__)


class XSLTTransformer:
    """Handles XSLT transformations from TEI XML to multiple formats"""

    def __init__(self, xslt_dir: Optional[Union[str, Path]] = None):
        self.xslt_dir = Path(xslt_dir) if xslt_dir else Path("xslt")
        self.temp_dir = None

        # Ensure XSLT directory exists
        self.xslt_dir.mkdir(exist_ok=True)

        # Create XSLT stylesheets
        self._create_xslt_stylesheets()

    def _create_xslt_stylesheets(self) -> None:
        """Create XSLT stylesheets for different output formats"""

        # HTML XSLT
        self._create_html_xslt()

        # LaTeX XSLT
        self._create_latex_xslt()

        # EPUB XSLT (based on HTML)
        self._create_epub_xslt()

        # DOCX XSLT (simplified, might need external tools)
        self._create_docx_xslt()

    def _create_html_xslt(self) -> None:
        """Create HTML XSLT stylesheet"""
        html_xslt = """<?xml version="1.0" encoding="UTF-8"?>
<xsl:stylesheet version="1.0" 
    xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    xmlns:tei="http://www.tei-c.org/ns/1.0"
    xmlns="http://www.w3.org/1999/xhtml"
    exclude-result-prefixes="tei">

<xsl:output method="xml" 
    doctype-public="-//W3C//DTD XHTML 1.1//EN"
    doctype-system="http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"
    indent="yes" encoding="UTF-8"/>

<xsl:template match="/tei:TEI">
    <html xml:lang="{@xml:lang}">
        <head>
            <title><xsl:value-of select="tei:teiHeader/tei:fileDesc/tei:titleStmt/tei:title"/></title>
            <meta charset="UTF-8"/>
            <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
            <style>
                body { font-family: 'Georgia', serif; line-height: 1.6; max-width: 800px; margin: 0 auto; padding: 20px; }
                .page { border-bottom: 2px solid #333; margin-bottom: 40px; padding-bottom: 20px; }
                .page-title { color: #2c3e50; border-bottom: 1px solid #3498db; padding-bottom: 10px; }
                .metadata { background: #f8f9fa; padding: 15px; border-radius: 5px; margin: 20px 0; }
                .metadata p { margin: 5px 0; }
                .toc { background: #e3f2fd; padding: 20px; margin: 20px 0; border-radius: 5px; }
                .toc ul { list-style-type: none; padding-left: 0; }
                .toc li { margin: 5px 0; }
                .toc a { text-decoration: none; color: #1976d2; }
                .toc a:hover { text-decoration: underline; }
                h1, h2, h3, h4, h5, h6 { color: #2c3e50; }
                .formula { background: #f5f5f5; padding: 10px; border-radius: 3px; font-family: 'Courier New', monospace; }
                .quote { border-left: 4px solid #3498db; padding-left: 20px; margin: 20px 0; font-style: italic; }
                .code { background: #f8f9fa; padding: 10px; border-radius: 3px; font-family: 'Courier New', monospace; }
                .links { background: #e8f5e8; padding: 15px; border-radius: 5px; margin: 20px 0; }
                .links ul { list-style-type: disc; }
            </style>
        </head>
        <body>
            <header>
                <h1><xsl:value-of select="tei:teiHeader/tei:fileDesc/tei:titleStmt/tei:title"/></h1>
                <p class="author">By <xsl:value-of select="tei:teiHeader/tei:fileDesc/tei:titleStmt/tei:author/tei:name"/></p>
                <p class="date"><xsl:value-of select="tei:teiHeader/tei:fileDesc/tei:titleStmt/tei:date"/></p>
            </header>
            
            <xsl:if test="tei:text/tei:front">
                <section class="toc">
                    <h2>Table of Contents</h2>
                    <ul>
                        <xsl:for-each select="tei:text/tei:front//tei:div[@type='toc-entry']">
                            <li><a href="#{generate-id(.)}"><xsl:value-of select="tei:ref"/></a></li>
                        </xsl:for-each>
                    </ul>
                </section>
            </xsl:if>
            
            <main>
                <xsl:apply-templates select="tei:text/tei:body"/>
            </main>
            
            <footer>
                <p>Generated by Integral Philosophy Publishing System</p>
            </footer>
        </body>
    </html>
</xsl:template>

<xsl:template match="tei:div[@type='page']">
    <article class="page" id="{generate-id(.)}">
        <xsl:apply-templates/>
    </article>
</xsl:template>

<xsl:template match="tei:div[@type='metadata']">
    <div class="metadata">
        <xsl:apply-templates/>
    </div>
</xsl:template>

<xsl:template match="tei:div[@type='links']">
    <div class="links">
        <xsl:apply-templates/>
    </div>
</xsl:template>

<xsl:template match="tei:head">
    <h2 class="page-title"><xsl:value-of select="."/></h2>
</xsl:template>

<xsl:template match="tei:p[@type='url' or @type='language' or @type='description' or @type='keywords' or @type='scraped-date']">
    <p><xsl:value-of select="."/></p>
</xsl:template>

<xsl:template match="tei:p">
    <p><xsl:apply-templates/></p>
</xsl:template>

<xsl:template match="tei:ref">
    <a href="{@target}"><xsl:value-of select="."/></a>
</xsl:template>

<xsl:template match="tei:figure">
    <figure>
        <img src="{tei:graphic/@url}" alt="{tei:figDesc}"/>
        <figcaption><xsl:value-of select="tei:figDesc"/></figcaption>
    </figure>
</xsl:template>

<xsl:template match="tei:quote[@type='code']">
    <div class="code">
        <pre><xsl:value-of select="."/></pre>
    </div>
</xsl:template>

<xsl:template match="tei:formula">
    <div class="formula">
        <xsl:value-of select="."/>
    </div>
</xsl:template>

<xsl:template match="tei:list">
    <ul>
        <xsl:apply-templates/>
    </ul>
</xsl:template>

<xsl:template match="tei:item">
    <li><xsl:apply-templates/></li>
</xsl:template>

<xsl:template match="tei:quote">
    <blockquote class="quote">
        <xsl:apply-templates/>
    </blockquote>
</xsl:template>

<xsl:template match="tei:hi[@rend='bold']">
    <strong><xsl:apply-templates/></strong>
</xsl:template>

<xsl:template match="tei:hi[@rend='it']">
    <em><xsl:apply-templates/></em>
</xsl:template>

<xsl:template match="tei:hi[@rend='t']">
    <code><xsl:apply-templates/></code>
</xsl:template>

<xsl:template match="tei:span">
    <span><xsl:value-of select="."/></span>
</xsl:template>

</xsl:stylesheet>"""

        with open(self.xslt_dir / "tei_to_html.xslt", "w", encoding="utf-8") as f:
            f.write(html_xslt)

    def _create_latex_xslt(self) -> None:
        """Create LaTeX XSLT stylesheet"""
        latex_xslt = """<?xml version="1.0" encoding="UTF-8"?>
<xsl:stylesheet version="1.0"
    xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    xmlns:tei="http://www.tei-c.org/ns/1.0"
    exclude-result-prefixes="tei">

<xsl:output method="text" encoding="UTF-8"/>

<xsl:template match="/tei:TEI">
    <xsl:text>\\documentclass[12pt,a4paper]{article}
\\usepackage[T2A,T1]{fontenc}
\\usepackage[utf8]{inputenc}
\\usepackage[russian,english]{babel}
\\usepackage{amsmath,amssymb}
\\usepackage{graphicx}
\\usepackage{hyperref}
\\usepackage{geometry}
\\usepackage{fancyhdr}
\\usepackage{setspace}

\\geometry{a4paper,margin=2.5cm}
\\linespread{1.5}

\\title{</xsl:text>
    <xsl:value-of select="tei:teiHeader/tei:fileDesc/tei:titleStmt/tei:title"/>
    <xsl:text>}
\\author{</xsl:text>
    <xsl:value-of select="tei:teiHeader/tei:fileDesc/tei:titleStmt/tei:author/tei:name"/>
    <xsl:text>}
\\date{</xsl:text>
    <xsl:value-of select="tei:teiHeader/tei:fileDesc/tei:titleStmt/tei:date"/>
    <xsl:text>}

\\begin{document}
\\maketitle
\\tableofcontents
\\newpage

</xsl:text>
    
    <xsl:apply-templates select="tei:text/tei:body"/>
    
    <xsl:text>
\\end{document}
</xsl:text>
</xsl:template>

<xsl:template match="tei:div[@type='page']">
    <xsl:text>\\section*{</xsl:text>
    <xsl:value-of select="tei:head"/>
    <xsl:text>}
</xsl:text>
    <xsl:apply-templates select="*[not(self::tei:head)]"/>
    <xsl:text>\\newpage
</xsl:text>
</xsl:template>

<xsl:template match="tei:div[@type='metadata']">
    <xsl:text>\\begin{quote}
\\textbf{Metadata:}
</xsl:text>
    <xsl:for-each select="tei:p">
        <xsl:text>\\textit{</xsl:text>
        <xsl:value-of select="substring-before(., ':')"/>
        <xsl:text>:} </xsl:text>
        <xsl:value-of select="substring-after(., ':')"/>
        <xsl:text>\\\\
</xsl:text>
    </xsl:for-each>
    <xsl:text>\\end{quote}
</xsl:text>
</xsl:template>

<xsl:template match="tei:div[@type='links']">
    <xsl:text>\\textbf{Links:}
\\begin{itemize}
</xsl:text>
    <xsl:apply-templates select="tei:list/tei:item"/>
    <xsl:text>\\end{itemize}
</xsl:text>
</xsl:template>

<xsl:template match="tei:p">
    <xsl:text></xsl:text>
    <xsl:apply-templates/>
    <xsl:text>

</xsl:text>
</xsl:template>

<xsl:template match="tei:ref">
    <xsl:text>\\href{</xsl:text>
    <xsl:value-of select="@target"/>
    <xsl:text>}{</xsl:text>
    <xsl:value-of select="."/>
    <xsl:text>}</xsl:text>
</xsl:template>

<xsl:template match="tei:formula">
    <xsl:text>\\begin{equation}
</xsl:text>
    <xsl:value-of select="."/>
    <xsl:text>\\end{equation}
</xsl:text>
</xsl:template>

<xsl:template match="tei:quote[@type='code']">
    <xsl:text>\\begin{verbatim}
</xsl:text>
    <xsl:value-of select="."/>
    <xsl:text>\\end{verbatim}
</xsl:text>
</xsl:template>

<xsl:template match="tei:list">
    <xsl:text>\\begin{itemize}
</xsl:text>
    <xsl:apply-templates/>
    <xsl:text>\\end{itemize}
</xsl:text>
</xsl:template>

<xsl:template match="tei:item">
    <xsl:text>\\item </xsl:text>
    <xsl:value-of select="."/>
    <xsl:text>
</xsl:text>
</xsl:template>

<xsl:template match="tei:quote">
    <xsl:text>\\begin{quote}
\\textit{</xsl:text>
    <xsl:apply-templates/>
    <xsl:text>}
\\end{quote}
</xsl:text>
</xsl:template>

<xsl:template match="tei:hi[@rend='bold']">
    <xsl:text>\\textbf{</xsl:text>
    <xsl:apply-templates/>
    <xsl:text>}</xsl:text>
</xsl:template>

<xsl:template match="tei:hi[@rend='it']">
    <xsl:text>\\textit{</xsl:text>
    <xsl:apply-templates/>
    <xsl:text>}</xsl:text>
</xsl:template>

<xsl:template match="tei:hi[@rend='t']">
    <xsl:text>\\texttt{</xsl:text>
    <xsl:apply-templates/>
    <xsl:text>}</xsl:text>
</xsl:template>

</xsl:stylesheet>"""

        with open(self.xslt_dir / "tei_to_latex.xslt", "w", encoding="utf-8") as f:
            f.write(latex_xslt)

    def _create_epub_xslt(self) -> None:
        """Create EPUB XSLT stylesheet"""
        epub_xslt = """<?xml version="1.0" encoding="UTF-8"?>
<xsl:stylesheet version="1.0"
    xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    xmlns:tei="http://www.tei-c.org/ns/1.0"
    xmlns="http://www.w3.org/1999/xhtml"
    exclude-result-prefixes="tei">

<xsl:output method="xml" indent="yes" encoding="UTF-8"/>

<!-- EPUB specific - create separate chapters -->
<xsl:template match="/tei:TEI">
    <html xmlns="http://www.w3.org/1999/xhtml">
        <head>
            <title><xsl:value-of select="tei:teiHeader/tei:fileDesc/tei:titleStmt/tei:title"/></title>
            <meta charset="UTF-8"/>
            <style>
                body { font-family: serif; line-height: 1.4; margin: 1em; }
                .chapter { page-break-before: always; }
                .metadata { background: #f0f0f0; padding: 0.5em; margin: 1em 0; }
                h1 { color: #333; border-bottom: 2px solid #333; }
                h2 { color: #666; }
            </style>
        </head>
        <body>
            <div class="front-matter">
                <h1><xsl:value-of select="tei:teiHeader/tei:fileDesc/tei:titleStmt/tei:title"/></h1>
                <p>By <xsl:value-of select="tei:teiHeader/tei:fileDesc/tei:titleStmt/tei:author/tei:name"/></p>
                <p><xsl:value-of select="tei:teiHeader/tei:fileDesc/tei:titleStmt/tei:date"/></p>
            </div>
            
            <div class="table-of-contents">
                <h2>Table of Contents</h2>
                <ul>
                    <xsl:for-each select="tei:text/tei:body/tei:div[@type='page']">
                        <li><a href="#{generate-id(.)}"><xsl:value-of select="tei:head"/></a></li>
                    </xsl:for-each>
                </ul>
            </div>
            
            <xsl:apply-templates select="tei:text/tei:body"/>
        </body>
    </html>
</xsl:template>

<xsl:template match="tei:div[@type='page']">
    <div class="chapter" id="{generate-id(.)}">
        <h1><xsl:value-of select="tei:head"/></h1>
        <xsl:apply-templates select="*[not(self::tei:head)]"/>
    </div>
</xsl:template>

<xsl:template match="tei:div[@type='metadata']">
    <div class="metadata">
        <xsl:apply-templates/>
    </div>
</xsl:template>

<xsl:template match="tei:p">
    <p><xsl:apply-templates/></p>
</xsl:template>

<xsl:template match="tei:ref">
    <a href="{@target}"><xsl:value-of select="."/></a>
</xsl:template>

<xsl:template match="tei:list">
    <ul>
        <xsl:apply-templates/>
    </ul>
</xsl:template>

<xsl:template match="tei:item">
    <li><xsl:apply-templates/></li>
</xsl:template>

<xsl:template match="tei:hi[@rend='bold']">
    <strong><xsl:apply-templates/></strong>
</xsl:template>

<xsl:template match="tei:hi[@rend='it']">
    <em><xsl:apply-templates/></em>
</xsl:template>

</xsl:stylesheet>"""

        with open(self.xslt_dir / "tei_to_epub.xslt", "w", encoding="utf-8") as f:
            f.write(epub_xslt)

    def _create_docx_xslt(self) -> None:
        """Create DOCX XSLT stylesheet (simplified)"""
        docx_xslt = """<?xml version="1.0" encoding="UTF-8"?>
<xsl:stylesheet version="1.0"
    xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    xmlns:tei="http://www.tei-c.org/ns/1.0"
    xmlns:w="http://schemas.openxmlformats.org/wordprocessingml/2006/main"
    exclude-result-prefixes="tei">

<!-- DOCX is complex - this creates intermediate format for external processing -->

<xsl:output method="xml" indent="yes" encoding="UTF-8"/>

<xsl:template match="/tei:TEI">
    <document>
        <title><xsl:value-of select="tei:teiHeader/tei:fileDesc/tei:titleStmt/tei:title"/></title>
        <author><xsl:value-of select="tei:teiHeader/tei:fileDesc/tei:titleStmt/tei:author/tei:name"/></author>
        <date><xsl:value-of select="tei:teiHeader/tei:fileDesc/tei:titleStmt/tei:date"/></date>
        <content>
            <xsl:apply-templates select="tei:text/tei:body"/>
        </content>
    </document>
</xsl:template>

<xsl:template match="tei:div[@type='page']">
    <chapter>
        <title><xsl:value-of select="tei:head"/></title>
        <xsl:apply-templates select="*[not(self::tei:head)]"/>
    </chapter>
</xsl:template>

<xsl:template match="tei:p">
    <paragraph><xsl:apply-templates/></paragraph>
</xsl:template>

<xsl:template match="tei:hi[@rend='bold']">
    <bold><xsl:apply-templates/></bold>
</xsl:template>

<xsl:template match="tei:hi[@rend='it']">
    <italic><xsl:apply-templates/></italic>
</xsl:template>

</xsl:stylesheet>"""

        with open(self.xslt_dir / "tei_to_docx.xslt", "w", encoding="utf-8") as f:
            f.write(docx_xslt)

    def transform_to_html(
        self, tei_file: Union[str, Path], output_file: Union[str, Path]
    ) -> bool:
        """Transform TEI to HTML using XSLT"""
        try:
            # Use lxml for XSLT transformation
            from lxml import etree

            # Parse TEI file
            tei_doc = etree.parse(str(tei_file))
            xslt_doc = etree.parse(str(self.xslt_dir / "tei_to_html.xslt"))

            # Create transformer
            transform = etree.XSLT(xslt_doc)

            # Transform
            result_tree = transform(tei_doc)

            # Save result
            result_tree.write(
                str(output_file),
                encoding="utf-8",
                pretty_print=True,
                xml_declaration=True,
            )

            logger.info(f"HTML generated: {output_file}")
            return True

        except ImportError:
            logger.error("lxml not available. Install with: pip install lxml")
            return False
        except Exception as e:
            logger.error(f"Error transforming to HTML: {e}")
            return False

    def transform_to_latex(
        self, tei_file: Union[str, Path], output_file: Union[str, Path]
    ) -> bool:
        """Transform TEI to LaTeX using XSLT"""
        try:
            from lxml import etree

            # Parse TEI file
            tei_doc = etree.parse(str(tei_file))
            xslt_doc = etree.parse(str(self.xslt_dir / "tei_to_latex.xslt"))

            # Create transformer
            transform = etree.XSLT(xslt_doc)

            # Transform
            result_tree = transform(tei_doc)

            # Save result
            result_tree.write(str(output_file), encoding="utf-8")

            logger.info(f"LaTeX generated: {output_file}")
            return True

        except ImportError:
            logger.error("lxml not available. Install with: pip install lxml")
            return False
        except Exception as e:
            logger.error(f"Error transforming to LaTeX: {e}")
            return False

    def compile_latex_to_pdf(
        self, latex_file: Union[str, Path], output_file: Union[str, Path]
    ) -> bool:
        """Compile LaTeX to PDF"""
        try:
            # Try different LaTeX compilers
            compilers = ["pdflatex", "xelatex", "lualatex"]

            for compiler in compilers:
                try:
                    result = subprocess.run(
                        [compiler, str(latex_file)],
                        cwd=latex_file.parent,
                        capture_output=True,
                        text=True,
                        timeout=60,
                    )

                    if result.returncode == 0:
                        # Find generated PDF
                        pdf_path = latex_file.with_suffix(".pdf")
                        if pdf_path.exists():
                            shutil.move(str(pdf_path), str(output_file))
                            logger.info(f"PDF generated: {output_file}")
                            return True

                except FileNotFoundError:
                    continue
                except subprocess.TimeoutExpired:
                    logger.warning(f"LaTeX compilation timeout with {compiler}")
                    continue
                except Exception as e:
                    logger.warning(f"Error with {compiler}: {e}")
                    continue

            logger.error("LaTeX compiler not found or compilation failed")
            return False

        except Exception as e:
            logger.error(f"Error compiling LaTeX: {e}")
            return False

    def transform_to_epub(
        self, tei_file: Union[str, Path], output_file: Union[str, Path]
    ) -> bool:
        """Transform TEI to EPUB"""
        try:
            # Create temporary directory for EPUB structure
            with TemporaryDirectory() as temp_dir:
                temp_path = Path(temp_dir)

                # Create EPUB structure
                mimetype_file = temp_path / "mimetype"
                mimetype_file.write_text("application/epub+zip")

                # META-INF directory
                meta_inf = temp_path / "META-INF"
                meta_inf.mkdir()

                # container.xml
                container_xml = meta_inf / "container.xml"
                container_xml.write_text("""<?xml version="1.0"?>
<container version="1.0" xmlns="urn:oasis:names:tc:opendocument:xmlns:container">
  <rootfiles>
    <rootfile full-path="OEBPS/content.opf" media-type="application/oebps-package+xml"/>
  </rootfiles>
</container>""")

                # OEBPS directory
                oebps = temp_path / "OEBPS"
                oebps.mkdir()

                # Transform TEI to XHTML
                xhtml_file = oebps / "content.xhtml"
                if not self.transform_to_html(tei_file, xhtml_file):
                    return False

                # Create OPF file
                from lxml import etree

                tei_doc = etree.parse(str(tei_file))
                title = tei_doc.xpath(
                    "//tei:title/tei:ref/text()",
                    namespaces={"tei": "http://www.tei-c.org/ns/1.0"},
                )
                title = title[0] if title else "Document"

                opf_content = f"""<?xml version="1.0" encoding="UTF-8"?>
<package xmlns="http://www.idpf.org/2007/opf" unique-identifier="BookId" version="2.0">
  <metadata xmlns:dc="http://purl.org/dc/elements/1.1/">
    <dc:title>{title}</dc:title>
    <dc:language>en</dc:language>
    <dc:identifier id="BookId">urn:uuid:{title.replace(" ", "-")}-book</dc:identifier>
  </metadata>
  <manifest>
    <item id="content" href="content.xhtml" media-type="application/xhtml+xml"/>
  </manifest>
  <spine>
    <itemref idref="content"/>
  </spine>
</package>"""

                opf_file = oebps / "content.opf"
                opf_file.write_text(opf_content)

                # Create EPUB ZIP
                import zipfile

                with zipfile.ZipFile(
                    str(output_file), "w", zipfile.ZIP_DEFLATED
                ) as epub:
                    # Add mimetype first (uncompressed)
                    epub.write(
                        mimetype_file, "mimetype", compress_type=zipfile.ZIP_STORED
                    )

                    # Add other files
                    for root, dirs, files in os.walk(temp_path):
                        for file in files:
                            if file != "mimetype":
                                file_path = Path(root) / file
                                arc_path = file_path.relative_to(temp_path)
                                epub.write(file_path, arc_path)

                logger.info(f"EPUB generated: {output_file}")
                return True

        except Exception as e:
            logger.error(f"Error generating EPUB: {e}")
            return False

    def transform_to_docx(
        self, tei_file: Union[str, Path], output_file: Union[str, Path]
    ) -> bool:
        """Transform TEI to DOCX using external tools"""
        try:
            # Try using pandoc if available
            result = subprocess.run(
                [
                    "pandoc",
                    "-f",
                    "tei",
                    "-t",
                    "docx",
                    "-o",
                    str(output_file),
                    str(tei_file),
                ],
                capture_output=True,
                text=True,
            )

            if result.returncode == 0:
                logger.info(f"DOCX generated: {output_file}")
                return True
            else:
                logger.error(f"Pandoc error: {result.stderr}")
                return False

        except FileNotFoundError:
            logger.error(
                "Pandoc not found. Install with: apt-get install pandoc or brew install pandoc"
            )
            return False
        except Exception as e:
            logger.error(f"Error generating DOCX: {e}")
            return False

    def transform_all_formats(
        self, tei_file: Union[str, Path], output_dir: Union[str, Path]
    ) -> Dict[str, bool]:
        """Transform TEI to all supported formats"""
        output_dir = Path(output_dir)
        output_dir.mkdir(parents=True, exist_ok=True)

        results = {}

        # HTML
        html_output = output_dir / "document.html"
        results["html"] = self.transform_to_html(tei_file, html_output)

        # LaTeX
        latex_output = output_dir / "document.tex"
        if self.transform_to_latex(tei_file, latex_output):
            results["latex"] = True

            # PDF
            pdf_output = output_dir / "document.pdf"
            results["pdf"] = self.compile_latex_to_pdf(latex_output, pdf_output)
        else:
            results["latex"] = False
            results["pdf"] = False

        # EPUB
        epub_output = output_dir / "document.epub"
        results["epub"] = self.transform_to_epub(tei_file, epub_output)

        # DOCX
        docx_output = output_dir / "document.docx"
        results["docx"] = self.transform_to_docx(tei_file, docx_output)

        return results


def main():
    """Main function for testing"""
    import argparse

    parser = argparse.ArgumentParser(
        description="Transform TEI XML to multiple formats"
    )
    parser.add_argument("input", help="Input TEI XML file")
    parser.add_argument(
        "-o", "--output", default="transformed_output", help="Output directory"
    )
    parser.add_argument(
        "-f",
        "--format",
        choices=["html", "latex", "pdf", "epub", "docx", "all"],
        default="all",
        help="Output format",
    )
    parser.add_argument("--xslt-dir", help="XSLT stylesheets directory")

    args = parser.parse_args()

    # Create transformer
    transformer = XSLTTransformer(args.xslt_dir)

    if args.format == "all":
        results = transformer.transform_all_formats(args.input, args.output)
        for fmt, success in results.items():
            status = "✅" if success else "❌"
            print(f"{status} {fmt.upper()}: {'Success' if success else 'Failed'}")
    else:
        output_file = Path(args.output) / f"document.{args.format}"

        if args.format == "html":
            success = transformer.transform_to_html(args.input, output_file)
        elif args.format == "latex":
            success = transformer.transform_to_latex(args.input, output_file)
        elif args.format == "pdf":
            # First create LaTeX, then compile
            latex_file = output_file.with_suffix(".tex")
            if transformer.transform_to_latex(args.input, latex_file):
                success = transformer.compile_latex_to_pdf(latex_file, output_file)
            else:
                success = False
        elif args.format == "epub":
            success = transformer.transform_to_epub(args.input, output_file)
        elif args.format == "docx":
            success = transformer.transform_to_docx(args.input, output_file)
        else:
            print(f"Unsupported format: {args.format}")
            return

        status = "✅" if success else "❌"
        print(f"{status} {args.format.upper()}: {'Success' if success else 'Failed'}")


if __name__ == "__main__":
    main()
